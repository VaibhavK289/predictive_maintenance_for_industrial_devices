"""
Enterprise Predictive Maintenance - RAG Knowledge Base
Vector store with ChromaDB for maintenance documentation retrieval
"""
import os
from typing import List, Dict, Any, Optional
from pathlib import Path
import hashlib
import structlog
from datetime import datetime

import chromadb
from sentence_transformers import SentenceTransformer

from config.settings import get_settings
from schemas.models import KnowledgeDocument, QueryResult

logger = structlog.get_logger()
settings = get_settings()


class MaintenanceKnowledgeBase:
    """RAG-enabled knowledge base for maintenance documentation"""
    
    def __init__(self, persist_directory: Optional[str] = None):
        self.persist_directory = persist_directory or settings.vectordb.chroma_persist_dir
        self.collection_name = settings.vectordb.collection_name
        
        # Initialize local embedding model
        logger.info("Loading embedding model", model=settings.llm.embedding_model)
        self.embedding_model = SentenceTransformer(settings.llm.embedding_model)
        
        # Initialize ChromaDB client
        Path(self.persist_directory).mkdir(parents=True, exist_ok=True)
        self.chroma_client = chromadb.PersistentClient(path=self.persist_directory)
        
        # Initialize or get collection
        self.collection = self.chroma_client.get_or_create_collection(
            name=self.collection_name,
            metadata={"hnsw:space": settings.vectordb.distance_metric}
        )
        
        # Add default maintenance knowledge
        self._initialize_default_knowledge()
        
        logger.info("Knowledge base initialized", 
                   collection=self.collection_name,
                   documents=self.collection.count())
    
    def _generate_doc_id(self, content: str, source: str) -> str:
        """Generate unique document ID"""
        hash_input = f"{source}:{content[:200]}"
        return hashlib.sha256(hash_input.encode()).hexdigest()[:16]
    
    def _embed(self, texts: List[str]) -> List[List[float]]:
        """Generate embeddings for texts"""
        return self.embedding_model.encode(texts, convert_to_numpy=True).tolist()
    
    def _initialize_default_knowledge(self):
        """Add default maintenance knowledge to the knowledge base"""
        if self.collection.count() > 0:
            return
        
        default_docs = [
            {
                "content": """Heat Dissipation Failure (HDF): Occurs when the temperature difference between process 
                and air temperature is below 8.6K and rotational speed is below 1380 rpm. The heat generated by 
                the machining process cannot be dissipated effectively, leading to thermal stress and potential 
                component failure. Recommended action: Check cooling system, reduce machining speed, or implement 
                additional cooling measures.""",
                "source": "maintenance_manual_v1",
                "category": "failure_type"
            },
            {
                "content": """Power Failure (PWF): Occurs when the product of torque and rotational speed (power) 
                falls outside the optimal range. Power should typically be between 3500W and 9000W for normal 
                operation. Values outside this range indicate potential motor issues or incorrect load settings.
                Recommended action: Check motor condition, verify load settings, inspect drive system.""",
                "source": "maintenance_manual_v1",
                "category": "failure_type"
            },
            {
                "content": """Overstrain Failure (OSF): Caused by excessive mechanical stress on the machine 
                components. Occurs when the product of tool wear and torque exceeds safe thresholds, specifically
                when tool_wear * torque > 11,000 (for L type) or 12,000 (for M/H types) and torque is below minimum
                requirements. Recommended action: Replace worn tools immediately, reduce torque settings, 
                implement predictive tool replacement schedule.""",
                "source": "maintenance_manual_v1",
                "category": "failure_type"
            },
            {
                "content": """Tool Wear Failure (TWF): The tool wear time varies between 0 to 240 minutes. 
                Tools should be replaced when wear approaches 200 minutes to prevent quality issues.
                At 240 minutes, tool replacement is mandatory to prevent machine damage.
                Recommended action: Monitor tool wear continuously, schedule preventive replacements at 80% wear.""",
                "source": "maintenance_manual_v1",
                "category": "failure_type"
            },
            {
                "content": """Random Failure (RNF): Random failures occur with a probability of 0.1% regardless 
                of process parameters. These are unpredictable failures that require robust monitoring and 
                quick response capabilities. Recommended action: Maintain spare parts inventory, implement 
                real-time monitoring, have emergency response procedures in place.""",
                "source": "maintenance_manual_v1",
                "category": "failure_type"
            },
            {
                "content": """Optimal Operating Parameters for Industrial Machines:
                - Air Temperature: 295-305 K (22-32°C)
                - Process Temperature: 305-315 K (32-42°C)
                - Temperature Difference: 8.6K minimum for adequate heat dissipation
                - Rotational Speed: 1200-2800 rpm depending on machine type
                - Torque: 20-70 Nm for most operations
                - Tool Wear Limit: Replace at 200 minutes, mandatory at 240 minutes
                - Power Output: 3500-9000 W for normal operation""",
                "source": "operations_guide_v2",
                "category": "operating_parameters"
            },
            {
                "content": """Machine Type Classifications:
                - Type L (Low): Entry-level machines with lower tolerances and power requirements
                - Type M (Medium): Standard production machines with balanced performance
                - Type H (High): High-precision machines requiring tighter tolerances and monitoring
                Each type has different failure thresholds and maintenance intervals.""",
                "source": "equipment_catalog",
                "category": "machine_types"
            },
            {
                "content": """Preventive Maintenance Schedule:
                - Daily: Visual inspection, temperature checks, lubrication levels
                - Weekly: Tool wear assessment, calibration verification, cleaning
                - Monthly: Full diagnostic scan, bearing inspection, alignment check
                - Quarterly: Complete overhaul, parts replacement, performance testing
                - Annual: Major maintenance, software updates, certification renewal""",
                "source": "maintenance_schedule_v3",
                "category": "maintenance_schedule"
            },
            {
                "content": """Cost Analysis for Predictive Maintenance:
                - Average cost of unplanned downtime: $10,300 per incident
                - Average cost of preventive maintenance: $2,050 per intervention
                - ROI of predictive maintenance: 5-10x cost reduction
                - Optimal prediction threshold: 30% failure probability for alerts
                - False positive cost vs missed failure trade-off analysis required""",
                "source": "financial_analysis_2024",
                "category": "cost_analysis"
            },
            {
                "content": """Emergency Response Procedures:
                1. Immediately halt machine operation when failure is detected
                2. Isolate power supply to prevent further damage
                3. Document failure conditions (temperature, speed, torque, etc.)
                4. Contact maintenance team with failure code and conditions
                5. Do not attempt restart until root cause analysis is complete
                6. File incident report within 24 hours""",
                "source": "safety_procedures",
                "category": "emergency_response"
            }
        ]
        
        # Add documents to collection
        ids = []
        documents = []
        metadatas = []
        
        for doc in default_docs:
            doc_id = self._generate_doc_id(doc["content"], doc["source"])
            ids.append(doc_id)
            documents.append(doc["content"])
            metadatas.append({
                "source": doc["source"],
                "category": doc["category"],
                "timestamp": datetime.now().isoformat()
            })
        
        embeddings = self._embed(documents)
        
        self.collection.add(
            ids=ids,
            embeddings=embeddings,
            documents=documents,
            metadatas=metadatas
        )
        
        logger.info("Added default knowledge base documents", count=len(default_docs))
    
    def add_document(self, document: KnowledgeDocument) -> str:
        """Add a document to the knowledge base"""
        doc_id = self._generate_doc_id(document.content, document.source)
        
        embedding = self._embed([document.content])[0]
        
        self.collection.add(
            ids=[doc_id],
            embeddings=[embedding],
            documents=[document.content],
            metadatas=[{
                "source": document.source,
                "category": document.category,
                "timestamp": document.timestamp.isoformat() if document.timestamp else datetime.now().isoformat()
            }]
        )
        
        logger.info("Added document to knowledge base", doc_id=doc_id, source=document.source)
        return doc_id
    
    def query(self, query_text: str, n_results: int = 5) -> QueryResult:
        """Query the knowledge base for relevant documents"""
        import time
        start_time = time.time()
        
        # Generate query embedding
        query_embedding = self._embed([query_text])[0]
        
        # Search collection
        results = self.collection.query(
            query_embeddings=[query_embedding],
            n_results=n_results,
            include=["documents", "metadatas", "distances"]
        )
        
        # Format results
        formatted_results = []
        sources = []
        retrieval_scores = []
        
        if results["documents"] and results["documents"][0]:
            for i, doc in enumerate(results["documents"][0]):
                formatted_results.append({
                    "content": doc,
                    "metadata": results["metadatas"][0][i] if results["metadatas"] else {},
                    "distance": results["distances"][0][i] if results["distances"] else 0
                })
                if results["metadatas"] and results["metadatas"][0]:
                    sources.append(results["metadatas"][0][i].get("source", "unknown"))
                if results["distances"] and results["distances"][0]:
                    # Convert distance to similarity score (1 - distance for cosine)
                    retrieval_scores.append(1 - results["distances"][0][i])
        
        # Generate answer by combining top results
        if formatted_results:
            context = "\n\n".join([r["content"] for r in formatted_results[:3]])
            generated_answer = f"Based on the maintenance knowledge base:\n\n{context}"
        else:
            generated_answer = "No relevant information found in the knowledge base."
        
        processing_time = (time.time() - start_time) * 1000
        
        return QueryResult(
            query=query_text,
            results=formatted_results,
            generated_answer=generated_answer,
            sources=sources,
            processing_time_ms=processing_time,
            retrieval_scores=retrieval_scores
        )
    
    def get_relevant_context(self, 
                             machine_type: str, 
                             sensor_data: Dict[str, Any],
                             failure_type: Optional[str] = None) -> str:
        """Get relevant maintenance context for a given machine and conditions"""
        # Build query based on sensor data
        query_parts = [f"Machine type {machine_type}"]
        
        if failure_type:
            query_parts.append(f"{failure_type} failure")
        
        if sensor_data.get("tool_wear", 0) > 180:
            query_parts.append("high tool wear maintenance")
        
        temp_diff = sensor_data.get("process_temperature", 0) - sensor_data.get("air_temperature", 0)
        if temp_diff < 8.6:
            query_parts.append("heat dissipation cooling")
        
        if sensor_data.get("torque", 0) > 60:
            query_parts.append("high torque overstrain")
        
        query = " ".join(query_parts)
        result = self.query(query, n_results=3)
        
        return result.generated_answer
    
    def get_failure_info(self, failure_type: str) -> Optional[Dict[str, Any]]:
        """Get detailed information about a specific failure type"""
        result = self.query(f"{failure_type} failure causes and recommended actions", n_results=2)
        
        if result.results:
            return {
                "failure_type": failure_type,
                "information": result.results[0]["content"],
                "sources": result.sources
            }
        return None
    
    def get_maintenance_recommendations(self, 
                                         machine_id: str,
                                         conditions: Dict[str, Any]) -> List[str]:
        """Get maintenance recommendations based on current conditions"""
        recommendations = []
        
        # Query for relevant recommendations
        query = f"maintenance recommendations for {conditions}"
        result = self.query(query, n_results=3)
        
        # Extract recommendations from results
        for r in result.results:
            content = r["content"]
            # Extract lines starting with "Recommended action:"
            for line in content.split("\n"):
                if "Recommended action:" in line or "recommended" in line.lower():
                    recommendations.append(line.strip())
        
        return recommendations[:5]  # Return top 5 recommendations
    
    def document_count(self) -> int:
        """Get the total number of documents in the knowledge base"""
        return self.collection.count()
    
    def clear(self):
        """Clear all documents from the knowledge base"""
        self.chroma_client.delete_collection(self.collection_name)
        self.collection = self.chroma_client.get_or_create_collection(
            name=self.collection_name,
            metadata={"hnsw:space": settings.vectordb.distance_metric}
        )
        logger.info("Knowledge base cleared")
